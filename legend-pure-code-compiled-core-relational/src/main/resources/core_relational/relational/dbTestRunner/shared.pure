// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::relational::runtime::*;
import meta::relational::dbTestRunner::*;
import meta::pure::alloy::connections::*;

Profile meta::relational::dbTestRunner::dbTest
{
   stereotypes : [ Test, Ignore, BeforePackage, AfterPackage];
}


Class meta::relational::dbTestRunner::DbTestCollection
{
  packageName :String[1];
  testFunctions : Function<{DbTestConfig[1] -> String[0..1]}>[*];
  beforeTests : Function<{DbTestConfig[1] -> String[0..1]}>[*];
  afterTests : Function<{DbTestConfig[1] -> String[0..1]}>[*];
  toFixTests : Function<{DbTestConfig[1] -> String[0..1]}>[*];
  subCollections : DbTestCollection[*];
}

function meta::relational::dbTestRunner::collectTests(packagePath: String[1]): DbTestCollection[1]
{
  $packagePath->pathToElement()->cast(@Package)->collectTests();
}

function meta::relational::dbTestRunner::collectTests(pack: Package[1]): DbTestCollection[1]
{
  ^DbTestCollection(
      packageName = $pack->elementToPath(),
      testFunctions = $pack.children->map(c| $c->match([
          f:Function<Any>[1]| if($f.stereotypes->contains(dbTest->stereotype('Test')), |$f->cast(@Function<{DbTestConfig[1] -> String[0..1]}>), |[]),
          x:Any[1]| []
      ])),
      beforeTests= $pack.children->map(c| $c->match([
          f:Function<Any>[1]| if($f.stereotypes->contains(dbTest->stereotype('BeforePackage')), |$f->cast(@Function<{DbTestConfig[1] -> String[0..1]}>), |[]),
          x:Any[1]| []
      ])),
      afterTests= $pack.children->map(c| $c->match([
          f:Function<Any>[1]| if($f.stereotypes->contains(dbTest->stereotype('AfterPackage')), |$f->cast(@Function<{DbTestConfig[1] -> String[0..1]}>), |[]),
          x:Any[1]| []
      ])),
      toFixTests= $pack.children->map(c| $c->match([
          f:Function<Any>[1]| if($f.stereotypes->contains(dbTest->stereotype('Ignore')), |$f->cast(@Function<{DbTestConfig[1] -> String[0..1]}>), |[]),
          x:Any[1]| []
      ])),
      subCollections= $pack.children->map(c| $c->match([
          p:Package[1]| collectTests($p),
          x:Any[1]| []
      ]))
  );
}

Class meta::relational::dbTestRunner::DbTestConfig
{
   dbType: DatabaseType[1];
   connection: RelationalDatabaseConnection[0..1];
   expectedSql: String[0..1];
}

function meta::relational::dbTestRunner::createDbTestConfig(dbTypeStr: String[1]): DbTestConfig[1]
{
  createDbTestConfig($dbTypeStr,[]);
}

function meta::relational::dbTestRunner::createDbTestConfig(dbTypeStr: String[1], expectedSql:String[0..1]): DbTestConfig[1]
{
  let dbType = extractEnumValue(meta::relational::runtime::DatabaseType, $dbTypeStr);
  meta::relational::dbTestRunner::createDbTestConfig($dbType, $expectedSql);
}

function meta::relational::dbTestRunner::createDbTestConfig(dbType: meta::relational::runtime::DatabaseType[1], expectedSql:String[0..1]): DbTestConfig[1]
{
  let connection = meta::relational::dbTestRunner::getTestConnection($dbType, meta::pure::router::extension::defaultRelationalExtensions());
  ^DbTestConfig(dbType=$dbType, connection=$connection, expectedSql=$expectedSql);
}

//helper function to run db specific tests from pure ide ( for development only)
function meta::relational::dbTestRunner::runTestsWith(
                                               testCollection: DbTestCollection[1],
                                               subTestCollectionsToIgnore : String[*],
                                               dbType: DatabaseType[1],
                                               connection: RelationalDatabaseConnection[0..1],
                                               expectedSqls: Map<Function<{DbTestConfig[1] -> String[0..1]}>, String>[0..1]
                                               ): Boolean[1]
{
  let summary= runTestsWith($testCollection, $subTestCollectionsToIgnore, $dbType, $connection, $expectedSqls, '');
  println('Test Summary : \n' +
          '    Tests Passed = ' +  $summary.testsPassed->toString()+ '\n' +
          '    Tests Failed = ' +  $summary.testsFailed->size()->toString() + 
                if($summary.testsFailed->isEmpty(), |'\n' , |$summary.testsFailed->joinStrings('\n                ','\n                ','\n')) + 
          '    Tests Ignored = ' + $summary.testsIgnored->toString() + '\n'
          );
          
  assert($summary.testsFailed->isEmpty());
}

Class meta::relational::dbTestRunner::TestSummary
{
  testsPassed: Integer[1];
  testsFailed : String[*];           // test Ids with corresponding errors
  testsIgnored: Integer[1];
}

function meta::relational::dbTestRunner::runTestsWith(
                                               testCollection: DbTestCollection[1],
                                               subTestCollectionsToIgnore : String[*],
                                               dbType: DatabaseType[1],
                                               connection: RelationalDatabaseConnection[0..1],
                                               expectedSqls: Map< Function<{DbTestConfig[1] -> String[0..1]}>, String >[0..1], 
                                               indent : String[1]
                                               ): TestSummary[1]
{
  println($indent+ 'Running Test Collection : ' +$testCollection.packageName +  ' for : '+ $dbType->toString());
  
  if($subTestCollectionsToIgnore->contains($testCollection.packageName),
     |  println($indent+ '      Test Collection Ignored');
       ^TestSummary( testsFailed =  [], 
                     testsIgnored = $testCollection.testFunctions->size() ,
                     testsPassed =  0);,
      | 
        $testCollection.beforeTests-> map(f| $f->eval(^DbTestConfig(dbType=$dbType, connection=$connection)));
      
        //list of failed test ids with corresponding error messages
        let failedTests = $testCollection.testFunctions->map(f|
            println($indent+'   running test : '+ $f->elementToPath());
            let result = $f->eval(^DbTestConfig(dbType=$dbType, connection=$connection, expectedSql=if($expectedSqls->isEmpty(), |[], |$expectedSqls->toOne()->get($f))));
            if($result->isEmpty(), |[], |$f->elementToPath() + ': ' + $result->toOne());
        );

        $testCollection.afterTests-> map(f| $f->eval(^DbTestConfig(dbType=$dbType, connection=$connection)));

        let testCollectionSummary = ^TestSummary( testsFailed = $failedTests, 
                                                  testsIgnored = 0,
                                                  testsPassed = $testCollection.testFunctions->size() - $failedTests->size());
        
        let subTestSummaries = $testCollection.subCollections->map(subCollection |runTestsWith($subCollection, $subTestCollectionsToIgnore, $dbType, $connection,  $expectedSqls, $indent+'    '));

        ^TestSummary( testsFailed =  $subTestSummaries.testsFailed->fold({x,y| $x->concatenate($y)},$testCollectionSummary.testsFailed), 
                      testsIgnored = $subTestSummaries.testsIgnored->fold({x,y| $x+$y},$testCollectionSummary.testsIgnored ), 
                      testsPassed =  $subTestSummaries.testsPassed ->fold({x,y| $x+$y},$testCollectionSummary.testsPassed ));
    );
}

function meta::relational::dbTestRunner::getTestConnection(dbType:DatabaseType[1], extensions:meta::pure::router::extension::RouterExtension[*]):RelationalDatabaseConnection[0..1]
{
  meta::legend::test::mayExecuteLegendTest
     (
       {clientVersion, serverVersion, serializationKind, host, port |
         let fStr = 'meta::protocols::pure::'+$clientVersion+'::invocation::execution::testConnection::getTestConnection_DatabaseType_1__String_1__Integer_1__RouterExtension_MANY__RelationalDatabaseConnection_$0_1$_';
         let xf = $fStr->pathToElement()->cast(@Function<{DatabaseType[1], String[1], Integer[1], meta::pure::router::extension::RouterExtension[*]->RelationalDatabaseConnection[0..1]}>);
         let res= $xf->evaluate([$dbType, $host, $port]->map(v|list($v))->concatenate(list($extensions)));
         if($res->isNotEmpty(), 
           |$res->toOne()->cast(@RelationalDatabaseConnection),
           | println('**** Warning **** : Test Connection for dbType: '+ $dbType->toString() + ' not available on Legend Engine Server, tests will only generate execution plans without asserting actual data');
             []->cast(@RelationalDatabaseConnection);
           );
         },
       { |
         println('**** Warning **** : Legend Engine Server not available');
         []->cast(@RelationalDatabaseConnection);
       }
     );
}