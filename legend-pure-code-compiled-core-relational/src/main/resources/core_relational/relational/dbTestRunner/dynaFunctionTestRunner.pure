// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::executionPlan::*;
import meta::pure::router::extension::*;
import meta::pure::mapping::*;
import meta::pure::runtime::*;
import meta::relational::metamodel::relation::*;
import meta::relational::metamodel::*;
import meta::relational::runtime::*;
import meta::relational::functions::sqlQueryToString::*;
import meta::relational::functions::typeInference::*;
import meta::relational::mapping::*;
import meta::relational::dbTestRunner::*;

function meta::relational::dbTestRunner::runDynaFunctionDatabaseTest(dynaFunc:DynaFunction[1], expectedResult : Literal[1..*], testConfig:DbTestConfig[1]): String[0..1]
{ 
  let sqlQuery = ^SelectSQLQuery(columns=[$dynaFunc]);
  let sqlString = sqlQueryToString($sqlQuery, $testConfig.dbType, []);

  if($testConfig.expectedSql->isNotEmpty() && ($testConfig.expectedSql->toOne() != $sqlString),
    | 'Sql assert failed ,expected sql: '+ $testConfig.expectedSql->toOne()  +', actual sql : ' + $sqlString;,
    | if($testConfig.connection->isEmpty(),
      |   [] ,                                                     // test Connection not available ,do nothing further,
      |  
          let conn1= $testConfig.connection->toOne();
          let conn = ^$conn1(element= ^Database(name='dummyDB'));                      // overwite given connection db 
          
          let expectedResultTypes = $expectedResult->map(e|$e->inferRelationalType())->toOneMany();
          let plan = wrapSQLStringInExecutionPlan($sqlString, $expectedResultTypes, $testConfig.dbType,$conn) ;
          
          let res = executePlan($plan,defaultRelationalExtensions());
          if($res->isEmpty(),
              | [],                                  //legend engine not available 
              | if (equal($res.values,$expectedResult.value),
                | [],
                | let expectedStr = $expectedResult.value->map(v|$v->toString())->makeString('[',', ',']');
                  let resStr = $res.values->map(v|$v->toString())->makeString('[',', ',']');
                  'Result assert failed ,expected Values : '+ $expectedStr  +', actual Values : ' + $resStr;
                );
              );
       );
    );
}

function meta::relational::dbTestRunner::wrapSQLStringInExecutionPlan(sqlString:String[1], resultTypes:meta::relational::metamodel::datatype::DataType[1..*], dbType:DatabaseType[1], connection:DatabaseConnection[1]):ExecutionPlan[1]
{
  let runtime = ^Runtime(connections=$connection);
  
  let resultType = ^DataTypeResultType(type= $resultTypes->at(0)->meta::relational::metamodel::datatype::dataTypeToCompatiblePureType());

  let resultColumns = $resultTypes->toIndexed()->map(e| 
            ^SQLResultColumn(label='result' + $e.first->toString(), dataType=$e.second));
  
  let sqlExecutionNode = ^SQLExecutionNode(
                        sqlQuery=$sqlString ,
                        connection=$connection , 
                        resultType=$resultType,
                        resultColumns=$resultColumns);

  ^ExecutionPlan(
    authDependent=false,
    runtime=$runtime,
    func={|true},
    mapping=^Mapping(name='dummyMapping'),
    rootExecutionNode=^RelationalDataTypeInstantiationExecutionNode(
          resultType=$resultType,
          executionNodes=[$sqlExecutionNode]
        )
    );
}

