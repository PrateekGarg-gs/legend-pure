// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::json::*;
import meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::*;
import meta::protocols::pure::vX_X_X::metamodel::domain::*;
import meta::protocols::pure::vX_X_X::metamodel::store::relational::mapping::*;
import meta::protocols::pure::vX_X_X::metamodel::runtime::*;
import meta::relational::metamodel::*;
import meta::pure::functions::meta::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::connection::*;
import meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::*;
import meta::protocols::pure::vX_X_X::metamodel::store::relational::element::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::model::*;

function meta::protocols::pure::vX_X_X::transformation::toPureGraph::connection::buildRelationalDatabaseConnection(connectionJSON:String[1], extensions:meta::pure::router::extension::RouterExtension[*]):meta::pure::alloy::connections::RelationalDatabaseConnection[0..1]
{
  println($connectionJSON);

  //TODO - proper json handling
  let protocolConn = meta::json::fromJSON($connectionJSON, 
                  meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::RelationalDatabaseConnection ,
                 ^JSONDeserializationConfig( 
                                            typeKeyName='_type',
                                             failOnUnknownProperties=false ,
                                             typeLookup = [
                                                            pair('delegatedKerberos', 'DelegatedKerberosAuthenticationStrategy'),
                                                            pair('userNamePassword', 'UserNamePasswordAuthenticationStrategy'),
                                                            pair('h2Default', 'DefaultH2AuthenticationStrategy'),
                                                            pair('test', 'TestDatabaseAuthenticationStrategy'),
                                                            pair('snowflakePublic', 'SnowflakePublicAuthenticationStrategy'),
                                                            pair('gcpApplicationDefaultCredentials', 'GCPApplicationDefaultCredentialsAuthenticationStrategy'),

                                                            pair('static', 'StaticDatasourceSpecification'),
                                                            pair('h2Embedded', 'EmbeddedH2DatasourceSpecification'),
                                                            pair('h2Local', 'LocalH2DatasourceSpecification('),
                                                            pair('snowflake', 'SnowflakeDatasourceSpecification'),
                                                            pair('bigQuery', 'BigQueryDatasourceSpecification')
                                                          ]
                                            )
                );


  println('\nProtocol connection parsed from json');
  println($protocolConn);

  //TODO - proper DESERIALIZATION of connection
  let pureConn = $protocolConn->meta::protocols::pure::vX_X_X::transformation::toPureGraph::connection::transformDatabaseConnection($extensions);
  println('\nPure connection deserialized from protocol');
  println($pureConn);
  $pureConn->cast(@meta::pure::alloy::connections::RelationalDatabaseConnection); 
}


function meta::protocols::pure::vX_X_X::transformation::toPureGraph::connection::transformDatabaseConnection(conn : meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::DatabaseConnection[1] , extensions:meta::pure::router::extension::RouterExtension[*]):meta::relational::runtime::DatabaseConnection[1]
{
  let element = if($conn.element=='',                               // rather than root element , here it means dumy store
                  | ^Database(name='dummyDB'),
                  | $conn.element->pathToElement()
                  );

  let type =  extractEnumValue(meta::relational::runtime::DatabaseType, $conn.type);

  $conn->match([
    relational:meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::RelationalDatabaseConnection[1]|
          ^meta::pure::alloy::connections::RelationalDatabaseConnection(
              timeZone = $relational.timeZone,
              quoteIdentifiers = $relational.quoteIdentifiers,
              element = $element,
              type = $type,
              datasourceSpecification = $relational.datasourceSpecification->meta::protocols::pure::vX_X_X::transformation::toPureGraph::connection::transformDatasourceSpecification($extensions),
              authenticationStrategy = $relational.authenticationStrategy->meta::protocols::pure::vX_X_X::transformation::toPureGraph::connection::transformAuthenticationStrategy($extensions),
              postProcessors = []   // TODO
            );
    ]);
}

function meta::protocols::pure::vX_X_X::transformation::toPureGraph::connection::transformAuthenticationStrategy(a: meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::alloy::authentication::AuthenticationStrategy[1], extensions:meta::pure::router::extension::RouterExtension[*]):meta::pure::alloy::connections::alloy::authentication::AuthenticationStrategy[1]
{  
  // TODO - deserializer extensions ?

  $a->match([
      d:meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::alloy::authentication::DelegatedKerberosAuthenticationStrategy[1] |
          ^meta::pure::alloy::connections::alloy::authentication::DelegatedKerberosAuthenticationStrategy(
              // _type = 'delegatedKerberos',
              serverPrincipal = $d.serverPrincipal
          ),
      u:meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::alloy::authentication::UserNamePasswordAuthenticationStrategy[1] |
          ^meta::pure::alloy::connections::alloy::authentication::UserNamePasswordAuthenticationStrategy(
              // _type = 'userNamePassword',
              baseVaultReference = $u.baseVaultReference,
              userNameVaultReference = $u.userNameVaultReference,
              passwordVaultReference = $u.passwordVaultReference
            ),
      d:meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::alloy::authentication::DefaultH2AuthenticationStrategy[1] |
         ^meta::pure::alloy::connections::alloy::authentication::DefaultH2AuthenticationStrategy(
            // _type = 'h2Default'
         ),
      t:meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::alloy::authentication::TestDatabaseAuthenticationStrategy[1] |
         ^meta::pure::alloy::connections::alloy::authentication::TestDatabaseAuthenticationStrategy(
            // _type = 'test'
         ),
      s:meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::alloy::authentication::SnowflakePublicAuthenticationStrategy[1] |
        ^meta::pure::alloy::connections::alloy::authentication::SnowflakePublicAuthenticationStrategy(
            // _type = 'snowflakePublic',
            privateKeyVaultReference = $s.privateKeyVaultReference,
            passPhraseVaultReference = $s.passPhraseVaultReference,
            publicUserName = $s.publicUserName
        ),
      b:meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::alloy::authentication::GCPApplicationDefaultCredentialsAuthenticationStrategy[1] |
         ^meta::pure::alloy::connections::alloy::authentication::GCPApplicationDefaultCredentialsAuthenticationStrategy(
            // _type = 'gcpApplicationDefaultCredentials'
         )
   ]);
}

function meta::protocols::pure::vX_X_X::transformation::toPureGraph::connection::transformDatasourceSpecification(ds: meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::alloy::specification::DatasourceSpecification[1], extensions:meta::pure::router::extension::RouterExtension[*]):meta::pure::alloy::connections::alloy::specification::DatasourceSpecification[1]
{
   $ds->match([
      s:meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::alloy::specification::StaticDatasourceSpecification[1] |
         ^meta::pure::alloy::connections::alloy::specification::StaticDatasourceSpecification(
            // _type = 'static',
            host = $s.host,
            port = $s.port,
            databaseName = $s.databaseName
         ),
      e:meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::alloy::specification::EmbeddedH2DatasourceSpecification[1] |
         ^meta::pure::alloy::connections::alloy::specification::EmbeddedH2DatasourceSpecification(
            // _type = 'h2Embedded',
            databaseName = $e.databaseName,
            directory = $e.directory,
            autoServerMode = $e.autoServerMode
         ),
      l:meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::alloy::specification::LocalH2DatasourceSpecification[1] |
         ^meta::pure::alloy::connections::alloy::specification::LocalH2DatasourceSpecification(
            //  _type = 'h2Local',
             testDataSetupCsv = $l.testDataSetupCsv,
             testDataSetupSqls = $l.testDataSetupSqls
         ),
      s:meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::alloy::specification::SnowflakeDatasourceSpecification[1] |
        ^meta::pure::alloy::connections::alloy::specification::SnowflakeDatasourceSpecification(
            // _type = 'snowflake',
            accountName = $s.accountName,
            region = $s.region,
            warehouseName = $s.warehouseName,
            databaseName = $s.databaseName,
            cloudType = $s.cloudType,
            quotedIdentifiersIgnoreCase = $s.quotedIdentifiersIgnoreCase,
            proxyHost = $s.proxyHost,
            proxyPort = $s.proxyPort,
            nonProxyHosts = $s.nonProxyHosts,
            accountType = if($s.accountType->isEmpty(),|[],
                             |extractEnumValue(meta::pure::alloy::connections::alloy::specification::SnowflakeAccountType, $s.accountType->toOne())),
            organization = $s.organization,
            role = $s.role
        ),
      b:meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::alloy::specification::BigQueryDatasourceSpecification[1] |
         ^meta::pure::alloy::connections::alloy::specification::BigQueryDatasourceSpecification(
            //  _type = 'bigQuery',
             projectId = $b.projectId,
             defaultDataset = $b.defaultDataset
         )
   ]);
}