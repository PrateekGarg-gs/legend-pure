// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::mapping::*;
import meta::csv::*;
import meta::relational::functions::database::*;
import meta::relational::runtime::*;
import meta::pure::runtime::*;
import meta::relational::functions::pureToSqlQuery::*;
import meta::pure::router::routing::*;
import meta::pure::router::extension::*;
import meta::relational::metamodel::relation::*;
import meta::relational::metamodel::*;
import meta::relational::mapping::*;
import meta::relational::functions::toDDL::*;
import meta::relational::functions::sqlQueryToString::*;
import meta::relational::metamodel::datatype::*;
import meta::relational::functions::sqlQueryToString::*;

function meta::relational::functions::database::setUpData(t:String[1], mapping:Mapping[1]):String[*]
{
   let databases = $mapping->extractDBs()->removeDuplicates();

   print(if($databases->size() > 1, |'WARNING: The system found multiple databases in the mapping "'+$mapping->elementToPath()+'": '+$databases.name->joinStrings(','), |''));

   let database = if ($databases->size() == 1, | $databases->at(0), | ^Database(name='Default_CatchAll', includes = $databases));

   meta::alloy::service::execution::setUpDataSQLs($t, $database);
}

function meta::relational::functions::database::setUpData(t:String[1], mapping:Mapping[*], runtime:Runtime[1]):String[*]
{
   let databases = $mapping->extractDBs($runtime);

   let database = if ($databases->size() == 1, | $databases->at(0), | ^Database(name='Default_CatchAll', includes = $databases));

   meta::alloy::service::execution::setUpDataSQLs($t, $database);
}

function meta::relational::functions::database::setUpData(records:List<String>[*], mapping:Mapping[*], runtime:Runtime[1]):String[*]
{
   let databases = $mapping->extractDBs($runtime);

   let database = if ($databases->size() == 1, | $databases->at(0), | ^Database(name='Default_CatchAll', includes = $databases));

   meta::alloy::service::execution::setUpDataSQLs($records, $database);
}

function meta::alloy::service::execution::setUpDataSQLs(data:String[1], db:Database[1]) : String[*]
{
   let formattedData = $data->split('\n')
                            ->map(l|list($l->meta::alloy::service::execution::splitWithEmptyValue()))
                            ->concatenate(list(''));
  
    meta::alloy::service::execution::setUpDataSQLs($formattedData, $db);
}

// This function is needed because split does not preserve empty strings
// We work around by inserting a non-empty value, doing a split, and then removing the non-empty value
function <<access.private>> meta::alloy::service::execution::splitWithEmptyValue(s:String[1]) : String[*]
{
   let delimForEmptyCsvField = '|EMPTY|';

   $s->meta::alloy::service::execution::replaceWithEmptyValue($delimForEmptyCsvField)
        ->split(',')
        ->map(csv_val| if($csv_val == $delimForEmptyCsvField, | '' ,| $csv_val));
}

function <<access.private>> meta::alloy::service::execution::replaceWithEmptyValue(s:String[1], delimForEmptyCsvField: String[1]) : String[1]
{
   let news = if($s->endsWith(','), | $s + $delimForEmptyCsvField, |$s);

   let replaced = $news->replace(',,', ','+$delimForEmptyCsvField+',');

   if ($replaced->contains(',,'), | meta::alloy::service::execution::replaceWithEmptyValue($replaced, $delimForEmptyCsvField), | $replaced);
}

function  {doc.doc = 'Helper function generate a list of SQL commands to setup schemas and table from given store definition and insert given data'}
meta::alloy::service::execution::setUpDataSQLs(records:List<String>[*], db:Database[1]) : String[*]
{
   let schemaAndTableSetup = $db->meta::alloy::service::execution::schemaAndTableSetup();
   $schemaAndTableSetup->concatenate(loadCsvDataToDbTable($records, $db, t:Table[1]|$t));
}

//DDL SQL commands generation
function <<access.private>> meta::alloy::service::execution::schemaAndTableSetup(db:Database[1]):String[*]
{
   let allSchemas = $db->allSchemas();

   let schemaSetup = $allSchemas->map({schema |
      [
         meta::relational::functions::toDDL::dropSchemaStatement($schema.name),
         meta::relational::functions::toDDL::createSchemaStatement($schema.name)
      ]
   });

   let tableSetup = $allSchemas->map({schema |
      $schema.tables->map({t |
         [
            dropTableStatement($db, $schema.name, $t.name),
            createTableStatement($db, $schema.name, $t.name)
         ]
      })
   });

   $schemaSetup->concatenate($tableSetup);
}

function meta::relational::metamodel::allSchemas(n:Database[1]):Schema[*]
{
   let schemas = $n->allSchemasRecursive();
   $schemas->groupBy(s|$s.name)->keyValues()->map(p|
      let schema = $p.second.values->at(0);
      ^$schema(tables = $p.second.values.tables->removeDuplicates(), views = $p.second.values.views->removeDuplicates());
   );
}

function <<access.private>> meta::relational::metamodel::allSchemasRecursive(n:Database[1]):Schema[*]
{
   let schemas = $n.includes->map(d|$d->cast(@Database)->allSchemasRecursive())->concatenate($n.schemas);
}


//Data Insertion SQL Commands generation

Class meta::relational::functions::database::Res
{
   p : List<List<String>>[1];
   s : String[*];
}

function meta::relational::functions::database::loadCsvDataToDbTable(csvData:List<String>[*],
                                                         db:Database[1],
                                                         tablePostProcessor:Function<{Table[1]->Table[1]}>[1]
                                                         ) : String[*]
{
   
   loadCsvDataToDbTable($csvData, $db, createDbConfig(DatabaseType.H2), $tablePostProcessor);
}

function meta::relational::functions::database::loadCsvDataToDbTable(csvData:List<String>[*],
                                                         db:Database[1],
                                                         dbConfig:DbConfig[1],
                                                         tablePostProcessor:Function<{Table[1]->Table[1]}>[1]
                                                         ) : String[*]
{
   $csvData->fold({row,tab |if(($row.values->at(0) == '' || $row.values->at(0)->startsWith('-')) && !$tab.p.values->isEmpty() && $row.values->size()==1,
                                | let schemaName = $tab.p.values->at(0).values->at(0);
                                  let tableName = $tab.p.values->at(1).values->at(0);
                                  let columnNames = $tab.p.values->at(2).values;
                                  let schema = $db.schema($schemaName);
                                  assertNotEmpty($schema, | 'Schema "' + $schemaName + '" not found in database "' + $db->elementToPath() + '"');
                                  let table = $schema->toOne().table($tableName);
                                  assertNotEmpty($table,| 'Table "' + $tableName + '" not found in Schema "' + $schemaName + '" in Database "' + $db->elementToPath() + '"');
                                  let pTable = $tablePostProcessor->eval($table)->toOne();
                                  let columns = $columnNames->map(cName | let c = $pTable->toOne().columns->cast(@Column)->filter(tc| $tc.name->equalIgnoreCase($cName->trim()))->first();
                                                                          assertNotEmpty($c,| 'Column "' + $cName + '" not found in Table "' + $tableName + '" in Database "' + $db->elementToPath() + '"');
                                                                          $c;  );
                                  let sql = loadValuesToDbTable2(list($tab.p.values->slice(3,$tab.p.values->size())),
                                                       $pTable, $columns, $dbConfig);
                                  ^Res(p=^List<List<String>>(), s=$tab.s->concatenate($sql));,
                                | let r = $tab.p;
                                  ^Res(p=^$r(values+=$row), s = $tab.s);
                            );
                  },^Res(p=^List<List<String>>(), s = [])
            ).s;

}

function meta::relational::functions::database::loadValuesToDbTable2(data : List<List<String>>[1], table:Table[1], columns : Column[*]) : String[*]
{
   // Default to H2
   let h2DbConfig = createDbConfig(DatabaseType.H2);
   loadValuesToDbTable2($data, $table, $columns, $h2DbConfig);
}

function meta::relational::functions::database::loadValuesToDbTable2(data : List<List<String>>[1], table:Table[1],columns : Column[*], dbConfig: DbConfig[1]) : String[*]
{
   $data.values->map(row |  let sql = 'insert into ' + if($table.schema.name=='default', |'' ,|$table.schema.name + '.') + $table.name + ' ('
            + $columns.name->map(colName | $colName->meta::relational::functions::sqlQueryToString::processColumnName($dbConfig))->joinStrings(',')
            +') '
            + 'values ('
            + $row.values->meta::relational::functions::database::testDataSQLgeneration::convertValuesToCsv($columns.type)
            + ');';
   );
}

function meta::relational::functions::database::testDataSQLgeneration::convertValuesToCsv(str : String[*], types : Any[*]):String[1]
{
   // the split function is not working properly: csv records of the form x,,x,,e are not split with empty Strings
   // Therefor we insert ---null--- for now instead of empty set.
   // $value == '---null---' needs to be removed when split is fixed
   let stringToken = map(range($types->size()), {x |if($str->at($x) == '' || $str->at($x) == '---null---', |'null', |$types->at($x)->match([
                 s:Varchar[*] | '\'' + $str->at($x)->replace('\'', '\'\'') + '\'',
                 s:SemiStructured[*] | '\'' + $str->at($x)->replace('\'', '\'\'') + '\'',
                 s:meta::relational::metamodel::datatype::Char[*] | '\'' + $str->at($x)->replace('\'', '\'\'') + '\'',
                 d:meta::relational::metamodel::datatype::Date[*] |  '\'' + $str->at($x) + '\'',
                 t:meta::relational::metamodel::datatype::Timestamp[*] |  '\'' + if($str->at($x)->length() > 10, |$str->at($x), |$str->at($x)) + '\'',
                 a:Any[*] | $str->at($x)
                 ]))})->joinStrings(',');
}


//extractDBs
function meta::relational::runtime::extractDBs(m:meta::pure::mapping::Mapping[*], r:Runtime[1]):Database[*]
{
   let allMappings = $m->concatenate(getMappingsFromRuntime($r));

   let dbFromMappings = $allMappings->map(m| let db = $m->extractDBs();
                                            print(if($db->size() > 1, |'WARNING: The system found multiple databases in the mapping "'+$m->elementToPath()+'": '+$db.name->joinStrings(','), |''));
                                            $db;);
   let dbFromRuntime = $r.connections.element->filter(c | $c->instanceOf(Database))->cast(@Database);

   $dbFromMappings->concatenate($dbFromRuntime)->removeDuplicates();
}

function meta::relational::runtime::extractDBs(m:meta::pure::mapping::Mapping[1]):Database[*]
{
   $m->extractDBs($m);
}

function <<access.private>> meta::relational::runtime::extractDBs(m:meta::pure::mapping::Mapping[1], topMapping: meta::pure::mapping::Mapping[1]):Database[*]
{
   $m.includes.included->map(i|$i->extractDBs($topMapping))
   ->concatenate(
      $m.classMappings->filter(r|$r->instanceOf(meta::relational::mapping::RootRelationalInstanceSetImplementation))->cast(@meta::relational::mapping::RootRelationalInstanceSetImplementation).mainTableAlias.database->map(n|$topMapping.resolveStore($n)->cast(@Database))
   )->removeDuplicates();
}



