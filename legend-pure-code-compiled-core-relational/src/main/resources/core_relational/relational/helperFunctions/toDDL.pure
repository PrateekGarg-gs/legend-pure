// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::relational::functions::database::*;
import meta::relational::functions::sqlQueryToString::*;
import meta::pure::metamodel::function::*;
import meta::relational::metamodel::*;
import meta::relational::metamodel::execute::*;
import meta::relational::functions::toDDL::*;
import meta::relational::runtime::*;
import meta::relational::metamodel::relation::*;
import apps::pure::api::relational::toDDL::*;

// execute DDL statements
function meta::relational::functions::toDDL::dropAndCreateTableInDb(database:Database[1], tableName: String[1], c:DatabaseConnection[1]) : Boolean[1]
{
    dropAndCreateTableInDb($database, 'default', $tableName, $c);
}

function meta::relational::functions::toDDL::dropAndCreateTableInDb(database:Database[1], schema: String[1], tableName: String[1], c:DatabaseConnection[1]) : Boolean[1]
{
   dropAndCreateTableInDb($database, $schema, $tableName, getTableToTableIdentityFunction(), $c, true, false);
}

function <<doc.deprecated>> meta::relational::functions::toDDL::dropAndCreateTableInDb(database:Database[1], schema: String[1], tableName: String[1], c:DatabaseConnection[1], applyConstraints:Boolean[1]) : Boolean[1]
{
   dropAndCreateTableInDb($database, $schema, $tableName, getTableToTableIdentityFunction(), $c, $applyConstraints, false);
}

function meta::relational::functions::toDDL::dropAndCreateTableInDb(database:Database[1], schema: String[1], tableName: String[1], tablePostProcess: Function<{Table[1]->Table[1]}>[1], c:DatabaseConnection[1]) : Boolean[1]
{
   dropAndCreateTableInDb($database, $schema, $tableName, $tablePostProcess, $c, true, false);
}

function meta::relational::functions::toDDL::dropAndCreateTableInDb(database:Database[1], schema: String[1], tableName: String[1], tablePostProcess: Function<{Table[1]->Table[1]}>[1], c:DatabaseConnection[1], applyConstraints:Boolean[1]) : Boolean[1]
{
   dropAndCreateTableInDb($database, $schema, $tableName, $tablePostProcess, $c, $applyConstraints, false);
}

function meta::relational::functions::toDDL::dropAndCreateTableInDb(database:Database[1], schema: String[1], tableName: String[1], tablePostProcess: Function<{Table[1]->Table[1]}>[1], c:DatabaseConnection[1], applyConstraints:Boolean[1], debug:Boolean[1]) : Boolean[1]
{
   executeInDb(dropTableStatement($database, $schema, $tableName, $tablePostProcess), $c, $debug);
   executeInDb(createTableStatement($database, $c.type, $schema, $tableName, $tablePostProcess, $applyConstraints), $c, $debug);
   true;
}

function meta::relational::functions::toDDL::dropAndCreateSchemaInDb(schema: String[1], c:DatabaseConnection[1]) : Boolean[1]
{
   dropAndCreateSchemaInDb($schema, $c, false);
}

function meta::relational::functions::toDDL::dropAndCreateSchemaInDb(schema: String[1], c:DatabaseConnection[1], debug:Boolean[1]) : Boolean[1]
{
   executeInDb(dropSchemaStatement($schema), $c, $debug);
   executeInDb(createSchemaStatement($schema), $c, $debug);
   true;
}

function
{doc.doc = 'Input CSV file must contain one empty line between each table and two empty lines after the last table'}
meta::relational::functions::database::loadCsvDataToDbTable(csvData:List<String>[*],
                                                         db:Database[1],
                                                         databaseConnection:DatabaseConnection[1],
                                                         tablePostProcessor:Function<{Table[1]->Table[1]}>[1]
                                                         ):Any[*]
{
   let dbConfig = createDbConfig($databaseConnection.type);
   loadCsvDataToDbTable($csvData, $db, $dbConfig, $tablePostProcessor)->map(sql|executeInDb($sql, $databaseConnection));
}


// generate DDL statements
//use corresponding functions parameterized with dbType instead
function <<doc.deprecated>> meta::relational::functions::toDDL::dropAndCreateTableSql(database:Database[1], schemaName:String[1], tableName:String[1], applyContraints:Boolean[1]):String[1]
{
   dropTableStatement($database, $schemaName, $tableName) + '\n'
   + createTableStatement($database, $schemaName, $tableName, getTableToTableIdentityFunction(), $applyContraints);
}

function <<doc.deprecated>> meta::relational::functions::toDDL::createSchemaStatement(schema:String[1]) : String[1]
{
   'Create Schema ' + $schema + ';';
}

function <<doc.deprecated>> meta::relational::functions::toDDL::dropSchemaStatement(schema:String[1]) : String[1]
{
   'Drop schema if exists ' + $schema + ' cascade;';
}

function <<doc.deprecated>> meta::relational::functions::toDDL::dropTableStatement(database:Database[1], tableName: String[1]) : String[1]
{
    dropTableStatement($database, 'default', $tableName);
}

function <<doc.deprecated>> meta::relational::functions::toDDL::dropTableStatement(database:Database[1], schema: String[1], tableName: String[1]) : String[1]
{
   dropTableStatement($database, $schema, $tableName, getTableToTableIdentityFunction());
}

function <<doc.deprecated>> meta::relational::functions::toDDL::dropTableStatement(database:Database[1], schema: String[1], tableName: String[1], tablePostProcess: Function<{Table[1]->Table[1]}>[1]) : String[1]
{
   let t = $tablePostProcess->eval(getTable($database, $schema, $tableName));
   dropTableStatement($t);
}

function  <<doc.deprecated>> meta::relational::functions::toDDL::dropTableStatement(t:Table[1]) : String[1]
{
  'Drop table if exists '+if($t.schema.name == 'default',|'',|$t.schema.name+'.')+$t.name+';';
}

function <<doc.deprecated>> meta::relational::functions::toDDL::createTableStatement(database:Database[1], tableName: String[1]) : String[1]
{
    createTableStatement($database, 'default', $tableName);
}

function <<doc.deprecated>> meta::relational::functions::toDDL::createTableStatement(database:Database[1], schema: String[1], tableName: String[1]) : String[1]
{
   createTableStatement($database, $schema, $tableName, getTableToTableIdentityFunction(), true);
}

function <<access.private>> meta::relational::functions::toDDL::createTableStatement(database:Database[1], schema: String[1], tableName: String[1], tablePostProcess: Function<{Table[1]->Table[1]}>[1], applyConstraints:Boolean[1]) : String[1]
{
   // if no db type provided, then assume we are doing this for H2
   createTableStatement($database, DatabaseType.H2, $schema, $tableName, $tablePostProcess, $applyConstraints);
}

function <<access.private>> meta::relational::functions::toDDL::createTableStatement(database:Database[1], dbType:DatabaseType[1], schema: String[1], tableName: String[1], tablePostProcess: Function<{Table[1]->Table[1]}>[1], applyConstraints:Boolean[1]) : String[1]
{
   let t = $tablePostProcess->eval(getTable($database, $schema, $tableName));
   $t->createTableStatement($dbType, $applyConstraints);
}

function <<access.private>> meta::relational::functions::toDDL::createTableStatement(t:Table[1], dbType:DatabaseType[1],  applyConstraints:Boolean[1]) : String[1]
{
   let dbConfig = createDbConfig($dbType);

  'Create Table '+if($t.schema.name == 'default',|'',|$t.schema.name+'.')+$t.name+
      + '('
      + $t.columns->cast(@meta::relational::metamodel::Column)
         ->map(c | $c.name->meta::relational::functions::sqlQueryToString::processColumnName($dbConfig) + ' ' + meta::relational::functions::toDDL::getColumnTypeSqlText($c.type, $dbConfig.dbType) + if($c.nullable->isEmpty() || $applyConstraints == false, | '', | if($c.nullable == true , | ' NULL', | ' NOT NULL' )))
        ->joinStrings(',')
      + if ($t.primaryKey->isEmpty() || $applyConstraints == false, | '', | ', PRIMARY KEY(' + $t.primaryKey->map(c | $c.name)->joinStrings(',') + ')')
      +');';
}

function <<access.private>> meta::relational::functions::toDDL::getColumnTypeSqlText(columnType:meta::relational::metamodel::datatype::DataType[1], dbType:DatabaseType[1]):String[1] 
{
   $columnType->match([
      s : meta::relational::metamodel::datatype::SemiStructured[1] | $s->getSemiStructuredColumnTypeSqlText($dbType),
      a : Any[*] | meta::relational::metamodel::datatype::dataTypeToSqlText($columnType)
   ])
}

function <<access.private>> meta::relational::functions::toDDL::getSemiStructuredColumnTypeSqlText(columnType:meta::relational::metamodel::datatype::SemiStructured[1], dbType:DatabaseType[1]):String[1] 
{
   if ($dbType == DatabaseType.H2,
       | 'VARCHAR(4000)',
       | fail('DDL generation for semi structured type not supported for ' + $dbType->toString()); '';
   )
}

function meta::relational::functions::toDDL::buildInsertSQLQueryResultIntoTable(tableName: String[1], s:SelectSQLQuery[1], connection: DatabaseConnection[1], extensions:meta::pure::router::extension::RouterExtension[*], context:DebugContext[1]) : String[1]
{
   'insert into '+ $tableName+' ( '+sqlQueryToString($s, $connection.type, $connection.timeZone, $connection.quoteIdentifiers, $extensions)+' )';
}

function meta::relational::functions::toDDL::insertSQLQueryResultIntoTable(tableName: String[1], s:SelectSQLQuery[1], connection: DatabaseConnection[1], extensions:meta::pure::router::extension::RouterExtension[*], context:DebugContext[1]) : Any[0..1]
{
   let stmt = buildInsertSQLQueryResultIntoTable($tableName, $s, $connection, $extensions, $context);

   print(if(!$context.debug, |'', | $context.space+$stmt + '\n'));

   executeInDb($stmt, $connection);
}

function meta::relational::functions::toDDL::createTempTableStatement() : meta::pure::metamodel::function::Function<{String[1], Column[*], DatabaseType[1]->String[1]}>[1]
{
  {ttName:String[1], cols: Column[*], dbType: DatabaseType[1]|
        let colsAsString = '('+$cols->map(c|$c.name + ' ' + meta::relational::metamodel::datatype::dataTypeToSqlText($c.type))->joinStrings(',')+')';

        if($dbType == DatabaseType.H2,| 'Create LOCAL TEMPORARY TABLE '+$ttName+$colsAsString+';';
                                     ,| if([DatabaseType.Sybase, DatabaseType.SybaseIQ]->contains($dbType),| 'Declare LOCAL TEMPORARY TABLE '+$ttName+$colsAsString+' on commit preserve rows;'
                                                                                                          ,| assert(false, | 'Temporay table creation for db type: '+$dbType->toString()+' is not supported');'';));
  }
}

function meta::relational::functions::toDDL::getTableToTableIdentityFunction():Function<{Table[1]->Table[1]}>[1]
{
   {t:Table[1] |$t}
}

function <<access.private>> meta::relational::functions::toDDL::getTable(database:Database[1], schemaName: String[1], tableName: String[1]):Table[1]
{
   let schema = $database.schema($schemaName);

   if ($schema->isEmpty(), | fail('No schema found with name ' + $schemaName + ' in ' + $database.name->toOne()); [];, | []);

   let t = $schema->toOne().table($tableName);

   if ($t->isEmpty(), | fail('No table found with name ' + $tableName + ' in schema ' + $schemaName + ' in ' + $database.name->toOne()); $t->toOne();, | $t->toOne());
}

function meta::relational::functions::toDDL::createSchemaStatement(schema:String[1], dbConfig:DbConfig[1]) : String[1]
{
   assert($dbConfig.dbExtension.relationalDatabaseCommandsProvider->size()==1, ' No unique commands provider found for given db config');
   $dbConfig.dbExtension.relationalDatabaseCommandsProvider.createSchema->eval($schema);
}

function meta::relational::functions::toDDL::dropSchemaStatement(schema:String[1], dbConfig:DbConfig[1]) : String[1]
{
   assert($dbConfig.dbExtension.relationalDatabaseCommandsProvider->size()==1, ' No unique commands provider found for given db config');
   $dbConfig.dbExtension.relationalDatabaseCommandsProvider.dropSchema->eval($schema);
}

function meta::relational::functions::toDDL::dropTableStatement(database:Database[1], tableName: String[1], dbConfig:DbConfig[1]) : String[1]
{
    dropTableStatement($database, 'default', $tableName, $dbConfig);
}

function meta::relational::functions::toDDL::dropTableStatement(database:Database[1], schema: String[1], tableName: String[1], dbConfig:DbConfig[1]) : String[1]
{
   dropTableStatement($database, $schema, $tableName, getTableToTableIdentityFunction(), $dbConfig);
}

function meta::relational::functions::toDDL::dropTableStatement(database:Database[1], schema: String[1], tableName: String[1], tablePostProcess: Function<{Table[1]->Table[1]}>[1], dbConfig:DbConfig[1]) : String[1]
{
   let t = $tablePostProcess->eval(getTable($database, $schema, $tableName));
   dropTableStatement($t, $dbConfig);
}

function  meta::relational::functions::toDDL::dropTableStatement(t:Table[1], dbConfig:DbConfig[1]) : String[1]
{
  assert($dbConfig.dbExtension.relationalDatabaseCommandsProvider->size()==1, ' No unique commands provider found for given db config');
  $dbConfig.dbExtension.relationalDatabaseCommandsProvider.dropTable->eval($t);
}

function meta::relational::functions::toDDL::createTableStatement(database:Database[1], tableName: String[1], dbConfig:DbConfig[1]) : String[1]
{
    createTableStatement($database, 'default', $tableName, $dbConfig);
}

function meta::relational::functions::toDDL::createTableStatement(database:Database[1], schema: String[1], tableName: String[1], dbConfig:DbConfig[1]) : String[1]
{
   createTableStatement($database, $schema, $tableName, getTableToTableIdentityFunction(), true, $dbConfig);
}

function <<access.private>> meta::relational::functions::toDDL::createTableStatement(database:Database[1], schema: String[1], tableName: String[1], tablePostProcess: Function<{Table[1]->Table[1]}>[1], applyConstraints:Boolean[1], dbConfig:DbConfig[1]) : String[1]
{
   let t = $tablePostProcess->eval(getTable($database, $schema, $tableName));
   $t->createTableStatement($applyConstraints, $dbConfig);
}

function  meta::relational::functions::toDDL::createTableStatement(t:Table[1], applyConstraints:Boolean[1], dbConfig:DbConfig[1]) : String[1]
{
   assert($dbConfig.dbExtension.relationalDatabaseCommandsProvider->size()==1, ' No unique commands provider found for given db config');
   $dbConfig.dbExtension.relationalDatabaseCommandsProvider.createTable->eval($t,  $applyConstraints , $dbConfig);
}

Class meta::relational::functions::sqlQueryToString::RelationalDatabaseCommandsProvider
{
  createSchema: Function<{String[1]->String[1]}>[1];
  dropSchema : Function<{String[1]->String[1]}>[1];

  dropTable : Function<{Table[1] -> String[1]}>[1];
  createTable : Function<{Table[1], Boolean[1], DbConfig[1]-> String[1]}>[1];

  loadValuesToDbTable: Function<{ List<List<String>>[1], Table[1], Column[*], DbConfig[1] ->  String[*]}>[1];
}

function meta::relational::functions::sqlQueryToString::createRelationalDatabaseCommandsProvider(dbType:DatabaseType[1]): RelationalDatabaseCommandsProvider[1]
{
   ^RelationalDatabaseCommandsProvider(
        createSchema =  meta::relational::functions::sqlQueryToString::createSchemaStatementH2_String_1__String_1_,
        dropSchema =  meta::relational::functions::sqlQueryToString::dropSchemaStatementH2_String_1__String_1_,
        createTable =  meta::relational::functions::sqlQueryToString::createTableStatementH2_Table_1__Boolean_1__DbConfig_1__String_1_,
        dropTable =  meta::relational::functions::sqlQueryToString::dropTableStatementH2_Table_1__String_1_,
        loadValuesToDbTable =  meta::relational::functions::sqlQueryToString::loadValuesToDbTableH2_List_1__Table_1__Column_MANY__DbConfig_1__String_MANY_
    );
}

function <<access.private>>  meta::relational::functions::sqlQueryToString::createSchemaStatementH2(schema:String[1]) : String[1]
{
   'Create Schema ' + $schema + ';';
}

function <<access.private>>  meta::relational::functions::sqlQueryToString::dropSchemaStatementH2(schema:String[1]) : String[1]
{
   'Drop schema if exists ' + $schema + ' cascade;';
}

function <<access.private>>  meta::relational::functions::sqlQueryToString::dropTableStatementH2(t:Table[1]) : String[1]
{
  'Drop table if exists '+if($t.schema.name == 'default',|'',|$t.schema.name+'.')+$t.name+';';
}

function <<access.private>>  meta::relational::functions::sqlQueryToString::createTableStatementH2(t:Table[1], applyConstraints:Boolean[1], dbConfig:DbConfig[1]) : String[1]
{
  'Create Table '+if($t.schema.name == 'default',|'',|$t.schema.name+'.')+$t.name+
      + '('
      + $t.columns->cast(@meta::relational::metamodel::Column)
         ->map(c | $c.name->meta::relational::functions::sqlQueryToString::processColumnName($dbConfig) + ' ' +  meta::relational::functions::sqlQueryToString::getColumnTypeSqlTextH2($c.type) + if($c.nullable->isEmpty() || $applyConstraints == false, | '', | if($c.nullable == true , | ' NULL', | ' NOT NULL' )))
        ->joinStrings(',')
      + if ($t.primaryKey->isEmpty() || $applyConstraints == false, | '', | ', PRIMARY KEY(' + $t.primaryKey->map(c | $c.name)->joinStrings(',') + ')')
      +');';
}

function <<access.private>>  meta::relational::functions::sqlQueryToString::getColumnTypeSqlTextH2(columnType:meta::relational::metamodel::datatype::DataType[1]):String[1] 
{
   $columnType->match([
      s : meta::relational::metamodel::datatype::SemiStructured[1] | 'VARCHAR(4000)',
      a : Any[*] | meta::relational::metamodel::datatype::dataTypeToSqlText($columnType)
   ])
}

function <<access.private>>  meta::relational::functions::sqlQueryToString::loadValuesToDbTableH2(data :List<List<String>>[1], table:Table[1],columns : Column[*], dbConfig: DbConfig[1]) : String[*]
{
    $data.values->map(row |  let sql = 'insert into ' + if($table.schema.name=='default', |'' ,|$table.schema.name + '.') + $table.name + ' ('
            + $columns.name->map(colName | $colName->meta::relational::functions::sqlQueryToString::processColumnName($dbConfig))->joinStrings(',')
            +') '
            + 'values ('
            + $row.values->meta::relational::functions::database::testDataSQLgeneration::convertValuesToCsv($columns.type)
            + ');';
   );
}